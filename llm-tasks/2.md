# 2 – Bitemporal Visualizer Initial Implementation

Related issue(s): Task 2
Source of truth for task status: the external issue tracker.

---

## Task Summary

Transform the starter app into a bitemporal visualizer with:
- A main canvas panel showing a grid with valid time (x-axis) and system time (y-axis)
- Bitemporal events rendered as colored rectangles
- A side panel with controls
- Interactive drag-and-drop for events
- Multi-select and batch operations

---

## Current Understanding

**Bitemporal events have:**
- `_valid_from`: float (0..1) - start of valid time range
- `_valid_to`: float (0..1) - end of valid time range
- `_system_from`: float (0..1) - when the event was recorded in the system
- `_system_to`: implicitly infinity (events extend to top of canvas)
- `color`: RGB tuple as JS array `[r, g, b]` - display color

**Rendering (multi-pass):**
1. Background: Clear canvas, grid lines, axes, labels
2. Events: Rectangles drawn back-to-front by `_system_from` value
3. Foreground: Optional overlay grid (toggle in sidebar)
4. Selection: Blue selection box drawn on top during drag-select

**Layout:**
- Left side panel (dark, 256px) with title and controls
- Main canvas area (fills remaining space)
- Presence counter fixed in bottom right corner

---

## What We've Implemented

- [x] Basic layout with side panel + main canvas
- [x] Canvas rendering with grid, axes, labels
- [x] Events as colored rectangles (open top = infinity)
- [x] Drag to move events
- [x] Resize handle on right edge of events
- [x] Multi-select via drag box on empty space
- [x] Multi-drag (drag selected events together)
- [x] Multi-resize with proportional scaling
- [x] localStorage persistence for events and settings
- [x] Grid overlay toggle checkbox

---

## Important Learnings

### Squint/ClojureScript
- **No `js->clj` or `clj->js`** - Squint represents everything as raw JS objects
- Maps are plain JS objects, vectors are JS arrays, keywords become strings
- Can pass data directly to `JSON.stringify`/`JSON.parse` without conversion
- See `dev/SQUINT.md` for reference

### Reagami
- **No React-style refs** - use `:on-render` lifecycle hook instead
- `:on-render` receives `(fn [node lifecycle data])` where lifecycle is `"mount"`, `"update"`, or `"unmount"`
- Must manually trigger re-renders with `add-watch` + `render`
- See `dev/REAGAMI.md` for reference

### Canvas Interaction Patterns
- Use `getBoundingClientRect()` to convert client coords to canvas coords
- Normalize to 0..1 coordinates for position-independent logic
- Hit testing: check events in reverse z-order (top first)
- Separate drag state atom to avoid unnecessary re-renders during drag

### Multi-select/Multi-drag
- Store offsets for each selected event relative to mouse position
- For proportional resize: find anchor point (leftmost), calculate scale factor, apply to all

---

## Important Files / Components

- `src/app/app.cljs` – Main app: state, event handlers, drag logic, components
- `src/app/canvas.cljs` – Canvas rendering: grid, axes, events, selection box
- `src/app/ably.cljs` – Ably presence (unchanged from starter)
- `dev/REAGAMI.md` – Reagami API reference notes
- `dev/SQUINT.md` – Squint differences from ClojureScript

---

## Configuration Constants

In `canvas.cljs`:
- `padding`: 50px margin around drawable area
- `grid-divisions`: 10 (creates 0.1 grid lines)
- `handle-width`: 8px resize handle

In `app.cljs` (must match canvas.cljs):
- `PADDING`: 50
- `HANDLE_WIDTH`: 8
- `MIN_DURATION`: 0.05 (minimum event width)

---

## State Structure

```clojure
;; Main state (persisted partially to localStorage)
{:presence-count 0      ; runtime only
 :events [...]          ; persisted
 :canvas-ref nil        ; runtime only
 :show-grid false}      ; persisted

;; Drag state (never persisted)
{:dragging nil          ; index of dragged event
 :mode nil              ; :move, :move-multi, :resize, :resize-multi, :select
 :offset-x 0
 :offset-y 0
 :multi-offsets {}      ; for multi-drag
 :anchor-point nil      ; for multi-resize
 :original-span nil     ; for multi-resize
 :original-positions {} ; for multi-resize
 :select-start nil      ; for selection box
 :select-end nil
 :selected #{}}         ; set of selected indices
```

---

## Reasoning Notes

- Switched from `:ref` callback to `:on-render` lifecycle after discovering Reagami doesn't support React-style refs
- Removed `clj->js`/`js->clj` calls after learning Squint uses native JS objects
- Multi-resize changed from "add same delta" to "proportional scaling" based on user feedback
